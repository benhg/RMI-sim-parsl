# Imports

from numpy import zeros, sqrt, arange, array, savetxt, vstack
from math import exp, pi, cos, sin
from random import random, randint, uniform
from multiprocessing import Pool
from pylab import plot, title, xlabel, ylabel, \
    legend, show, savefig, xlim
import sys, time, datetime

# Parameters

todate = datetime.date.today()

size_global = int(sys.argv[1])    # Linear lattice size
output_path = 'output_data.txt'     # Directory path

if size_global == 16:   # Equilibration times
    tau_global = 10240
    tau_after = 1000
elif size_global == 24:
    tau_global = 14000
    tau_after = 1200
elif size_global == 32:
    tau_global = 21000
    tau_after = 4000
elif size_global == 40:
    tau_global = 31000
    tau_after = 3900
elif size_global == 64:
    tau_global = 55000
    tau_after = 10000

E_measurements = int(sys.argv[3])

# Function block


def calcdE(J, lattice, spin, newspin, i, j):
    # Change in energy function
    global size_global
    size = size_global
    dE = 0.0
    neighbor = i - 1
    # Note periodic boundary conditions
    if neighbor > -1:
        dE += cos(newspin - lattice[neighbor, j]) - \
            cos(spin - lattice[neighbor, j])
    else:
        dE += cos(newspin - lattice[size - 1, j]) - \
            cos(spin - lattice[size - 1, j])
    neighbor = i + 1
    if neighbor < size:
        dE += cos(newspin - lattice[neighbor, j]) -\
            cos(spin - lattice[neighbor, j])
    else:
        dE += cos(newspin - lattice[0, j]) - \
            cos(spin - lattice[0, j])
    neighbor = j - 1
    if neighbor > -1:
        dE += cos(newspin - lattice[i, neighbor]) - \
            cos(spin - lattice[i, neighbor])
    else:
        dE += cos(newspin - lattice[i, size - 1]) - \
            cos(spin - lattice[i, size - 1])
    neighbor = j + 1
    if neighbor < size:
        dE += cos(newspin - lattice[i, neighbor]) - \
            cos(spin - lattice[i, neighbor])
    else:
        dE += cos(newspin - lattice[i, 0]) - \
            cos(spin - lattice[i, 0])
    dE *= -J

    return dE


def calcsigma(c, cpts):
    # Bootstrap error analysis
    resample = len(cpts)
    bootc = []
    for x in range(resample):
        bootci = 0.0
        for y in range(resample):
            z = randint(0, resample - 1)
            bootci += cpts[z]
        bootci /= resample
        bootc.append(bootci)
    sigma1 = 0.0
    for w in range(resample):
        sigma1 += (bootc[w] - c) ** 2
    sigma1 /= resample
    error = sqrt(sigma1)

    return error


def XYmcsim(T):
    # XY Monte Carlo Simulation
    equilibrium_test = 'no'    # For equilibrium
    global size_global, E_measurements, tau_global, tau_after
    J = 1
    kB = 1  # Boltzmann's constant
    beta = 1 / (kB * T)
    tau = tau_global
    if T > 20:
        tau = tau_after
    BM = E_measurements    # Number of independent measurements
    size = size_global
    N = size ** 2
    corr = 2 * tau
    steps = corr + BM * N
    L = zeros([size, size], float)    # Initial lattice all spin 0
    E = -2 * J * N  # Initially all set at 0

    print("N =", size, "x", size, "; XY model at T =", T)
    E_plot = []
    expectE = 0.0  # Expectation value for E
    E_raw = []

    # Main cycle

    for k in range(steps):
        # Choose random spin
        i = randint(0, size - 1)
        j = randint(0, size - 1)
        s = L[i, j]
        # Generate random configuration
        config = uniform(0, 2 * pi)
        # Calculate change in energy:
        dE = calcdE(J, L, s, config, i, j)
        # Calculate Boltzmann probability
        P = exp(-beta * dE)
        # Accept or reject the spin
        if P > 1 or random() < P:
            L[i, j] = config
            E += dE
        if equilibrium_test == 'yes':
            E_plot.append(E)
        # Record raw data every sweep
        if k >= corr and k % N == 0:
            expectE += E
            E_raw.append(E)

    expectE /= len(E_raw)
    sigma_E = calcsigma(expectE, E_raw)
    
    if equilibrium_test == 'yes':
        plot(E_plot)
        show()

    return [T, expectE, sigma_E]


def XYunionsim(T):
    # XY Monte Carlo Simulation union, for RMI calculation
    global size_global, E_measurements, tau_global, tau_after
    J = 1
    kB = 1  # Boltzmann's constant
    beta = 1 / (kB * T)
    tau = tau_global
    if T > 20:
        tau = tau_after
    size = size_global
    BM = E_measurements
    n = 2
    N = size ** 2
    corr = 2 * tau
    steps = corr + BM * N
    L = zeros([size, size], float)    # Initial lattice all spin 0
    E = -2 * n * J * N     # Initially all set at 0

    print("N =", size, "x", size, "; XY union model at T =", T)
    expectE = 0.0  # Expectation value for E
    Eraw = []

    # Main cycle

    for k in range(steps):
        # Choose random spin
        i = randint(0, size - 1)
        j = randint(0, size - 1)
        s = L[i, j]
        # Generate random configuration
        config = uniform(0, 2 * pi)
        # Calculate change in energy:
        dE = 2 * calcdE(J, L, s, config, i, j)
        # Calculate Boltzmann probability
        P = exp(-beta * dE)
        # Accept or reject the spin
        if P > 1 or random() < P:
            L[i, j] = config
            E += dE
        # Record raw data every sweep
        if k >= corr and k % N == 0:
            expectE += E
            Eraw.append(E)

    expectE /= len(Eraw)
    sigma = calcsigma(expectE, Eraw)

    return [T, expectE, sigma]


def XYreplicasim(T):
    # XY replica Monte Carlo simulation
    global size_global, E_measurements, tau_global, tau_after
    J = 1
    kB = 1  # Boltzmann's constant
    beta = 1 / (kB * T)     # Temperature constant
    size = size_global   # Linear dimension of the lattice
    N = size ** 2
    n = 2   # Two replicas
    tau = tau_global
    if T > 20:
        tau = tau_after
    BM = E_measurements
    corr = 2 * tau
    steps = corr + BM * N
    L1 = zeros([size, size], float)    # Initial "left" lattice all spin 0
    L2 = zeros([size, size], float)   # "Right"
    E = -2 * J * n * N

    # Correlation conditions
    bound = size // 2
    A1 = L1[:, 0:bound]
    A2 = L2[:, 0:bound]

    print("N =", size, "x", size, "; Replica XY model at T =", T)
    expectE = 0.0   # Energy expectation value
    Eraw = []

    # Main cycle

    for k in range(steps):

        # Choose random spin
        i = randint(0, size - 1)
        j = randint(0, size - 1)
        s = L1[i, j]
        r = L2[i, j]
        # Generate random configuration
        config = uniform(0, 2 * pi)
        config2 = uniform(0, 2 * pi)
        if j < bound:
            config2 = config
        # Calculate change in energy:
        dE1 = calcdE(J, L1, s, config, i, j)
        dE2 = calcdE(J, L2, r, config2, i, j)
        dE = dE1 + dE2
        # Calculate Boltzmann probability
        P = exp(-beta * dE)
        # Accept or reject the spin
        if P > 1 or random() < P:
            E += dE
            L1[i, j] = config
            L2[i, j] = config2
        # Record raw data every sweep
        if k >= corr and k % N == 0:
            expectE += E
            Eraw.append(E)
        # Ensure A1 = A2
        if k == steps - 1:
            corrtest = 'yes'
            matches = 0
            if corrtest == 'yes':
                for columns in range(bound):
                    for rows in range(size):
                        if A1[rows, columns] == A2[rows, columns]:
                            matches += 1
            if matches == (size * bound):
                print("The replica is working great!")
            else:
                print("Something is wrong with the replica.")

    expectE /= len(Eraw)
    sigma = calcsigma(expectE, Eraw)

    return [T, expectE, sigma]


def vary_temps(Tm, TM, dT, savedata='yes'):
    global size_global, todate
    # Build temperature array, data[0]
    if Tm == 0:
        temps = arange(Tm + dT, TM + dT, dT)
    else:
        temps = arange(Tm, TM + dT, dT)

    # Separate core mapping to prevent memory error
    cores = Pool()
    result1 = cores.map(XYmcsim, temps)
    cores.close()
    cores.join()

    cores = Pool()
    result2 = cores.map(XYunionsim, temps)
    cores.close()
    cores.join()

    cores = Pool()
    result3 = cores.map(XYreplicasim, temps)
    cores.close()
    cores.join()

    normal = array(result1)
    AUB = array(result2)
    replica = array(result3)

    # Normal model
    T_plot = normal[:, 0]
    XY_E = normal[:, 1]
    XY_sigma = normal[:, 2]

    # AUB model
    AUB_E = AUB[:, 1]
    AUB_sigma = AUB[:, 2]

    # Replica model
    replica_E = replica[:, 1]
    replica_sigma = replica[:, 2]
    
    if savedata == 'yes':
        data = [T_plot, XY_E, XY_sigma, AUB_E, AUB_sigma, replica_E, replica_sigma]
        # Save to finished data
        path = '/home/users/briansmith/files/XY_model/finished_data'
        savetxt('{0}/RMI_XY;{1};{2};{3};{4}'.format(path, E_measurements, Tm, TM, dT), data)
    
    return [T_plot, replica_E, replica_sigma, AUB_E, AUB_sigma, XY_E, XY_sigma]


def calcRMI(T_min, T_max, Tstep):
    global size_global, todate, E_measurements
    size = size_global

    DATA = vary_temps(T_min, T_max, T_step)

    T_plot = DATA[0]
    # Replica data
    E_replica = DATA[1]
    sigma_replica = DATA[2]
    # AUB data
    E_AUB = DATA[3]
    sigma_AUB = DATA[4]
    # Normal data
    E_XY = DATA[5]
    sigma_XY = DATA[6]

    # Calculate RMI for each temperature
    print("Working on Renyi Mutual Information...")
    count = len(E_XY)
    RMIpts = []
    RMIsigmaplot = []
    deltaT = Tstep
    for i in range(count):
        RMI = 0.0
        sigma_sigma_i = 0.0
        for j in range(i, count):
            term = -deltaT * (2 * E_replica[j] - E_AUB[j] - 2 *
                              E_XY[j]) / (T_plot[j] ** 2)
            sigma_sigma_j = ((2 * deltaT) / ((T_plot[j] ** 2) * size * 2))\
                            ** 2 * (sigma_replica[j] ** 2) + (deltaT / ((T_plot[j] ** 2) *
                            size * 2)) ** 2 * (sigma_AUB[j] ** 2) + (
                            (2 * deltaT) / ((T_plot[j] ** 2) * size * 2))\
                            ** 2 * (sigma_XY[j] ** 2)
            sigma_sigma_i += sigma_sigma_j
            RMI += term
        sigma_i = sqrt(sigma_sigma_i)
        RMI /= 2 * size
        RMIpts.append(RMI)
        RMIsigmaplot.append(sigma_i)

    return [T_plot, RMIpts]


# Simulation console

if __name__ == "__main__":   # Required for multiprocessing on windows

    tstart = time.time()

    Tmin = float(sys.argv[4])
    Tmax = float(sys.argv[5])
    T_step = float(sys.argv[2])

    calcRMI(Tmin, Tmax, T_step)

    # End of main program

    t_elapse = (time.time() - tstart) / 3600
    print("Full program done in {0: .3f} hours.".format(t_elapse))
